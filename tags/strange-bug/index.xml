<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>strange-bug on ubiks232&#39;s blog</title>
    <link>https://ubiks232.github.io/tags/strange-bug/</link>
    <description>Recent content in strange-bug on ubiks232&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 12 Jan 2026 00:32:21 +0800</lastBuildDate><atom:link href="https://ubiks232.github.io/tags/strange-bug/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>STM32 Balance Car 1 ADC</title>
      <link>https://ubiks232.github.io/posts/stm32balancecar-1-adc/</link>
      <pubDate>Mon, 12 Jan 2026 00:32:21 +0800</pubDate>
      
      <guid>https://ubiks232.github.io/posts/stm32balancecar-1-adc/</guid>
      <description>铁头山羊的教程
adc相关bug 测试时遇到Delay()函数不能正确执行的bug, 有如下几个排查方向:
 Delay()是否被编译器优化? 该函数内部的变量更新是由__weak Systick_Handler()实现的, 这个中断处理是否能正常执行?  1 在Keil5调试界面的汇编代码对照中, 能够看到:
1 2 3  22: Delay(1000);0x08001BB6F44F707AMOVr0,#0x3E80x08001BBAF7FEFED7BL.W0x0800096CDelay  说明Delay()能被正确编译, 没有被优化.
2 在进入Delay()之后, 出现了突然跳到ADC1_2_IRAHandler的情况, 这个ADC1_2_IRAHandler被我用于处理ADC1转换得到的数据, 并且在调试卡死一段时间后, 又回到了Delay()中继续执行, 似乎并不能正确进入Systick_Handler().
此时我产生了两个怀疑: 1, Systick_Handler()是不是被优化掉了; 2, ADC1_2_IRQHandler似乎抢占了Systick_Handler()的执行.
首先看1, 在stm32f10x_it.c中查看Systick_Handler()的实现:
1 2 3 4 5 6 7 8 9  extern __IO uint32_t ulTicks; void SysTick_Handler(void) { if (SysTick-&amp;gt;CTRL &amp;amp; SysTick_CTRL_COUNTFLAG) { ulTicks++; } }   先声明了外部变量ulTicks, 然后根据ST公司提供的TM0056中的&amp;quot;Bit 16 COUNTFLAG: Returns 1 if timer counted to 0 since last time this was read.</description>
    </item>
    
    <item>
      <title>Zynq Linux 1 建立nfs</title>
      <link>https://ubiks232.github.io/posts/zynq-linux-1-%E5%BB%BA%E7%AB%8Bnfs/</link>
      <pubDate>Wed, 07 Jan 2026 18:21:39 +0800</pubDate>
      
      <guid>https://ubiks232.github.io/posts/zynq-linux-1-%E5%BB%BA%E7%AB%8Bnfs/</guid>
      <description>环境: Windows11 + WSL2的Ubuntu22.04, 开启Windows对WSL2的镜像网络, 在WSL2的配置(.wslconfig)中加上:
1 2  [wsl2] networkingMode=mirrored    1 Windows防火墙的入站许可-1(后面还要设置Windows的防火墙) 按照(Windows11下)Control Panel -&amp;gt; System and Security -&amp;gt; Windows Denfender Firewall -&amp;gt; Advanced Settings -&amp;gt; Inbound Rules -&amp;gt; 找到: File and Printer Sharing (Echo Request - ICMPv4-In), 然后右键点击Enable Rule, 这样允许zynq uboot通过以太网ping主机.
 2 配置以太网连接 由于开启了镜像网络, 因此WSL2上的虚拟机与Windows共享同一个网卡, 只需要将Windows的以太网设置好就行了.
比如我将Windows的eth设置成:
1 2  ipv4 addr: 192.168.2.10 netmask: 255.255.255.0   暂时先不设置网关, DNS, IPv6等内容. 在启动zynq上的Linux之前, 先中断系统引导停留在uboot阶段, 使用setenv配置网络, 将地址写为同一网段的地址.</description>
    </item>
    
    <item>
      <title>Windows下git Push显示permission Denied问题排查与解决</title>
      <link>https://ubiks232.github.io/posts/windows%E4%B8%8Bgit-push%E6%98%BE%E7%A4%BApermission-denied%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Sun, 04 Jan 2026 23:31:56 +0800</pubDate>
      
      <guid>https://ubiks232.github.io/posts/windows%E4%B8%8Bgit-push%E6%98%BE%E7%A4%BApermission-denied%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3/</guid>
      <description>1. Windows下ssh -T能通, 但是git push推送失败 2. 前提：ssh key已正确生成, 并且公钥已添加到GitHub(或其他 Git 平台). 3. 现象： 在PowerShell中执行git push报错：
1 2  git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.   但执行ssh -T git@github.com却显示认证成功.
4. 原因： git推送时使用的ssh可执行文件和测试用的ssh可执行文件不是同一个可执行文件.
使用where.exe ssh找到的是C:\Windows\System32\OpenSSH\ssh.exe, 而通过git config --global core.sshCommand发现, Git for Windows使用了它自带的ssh.exe(如.../Git/usr/bin/ssh.exe), 而该ssh与Windows的OpenSSH相比, 无法正确加载位于Windows用户目录下的私钥, 造成前面的问题.
5. 解决方法： 强制git使用Windows自带的 OpenSSH：
1  git config --global core.sshCommand &amp;#34;C:/Windows/System32/OpenSSH/ssh.exe&amp;#34;   之后再次执行git push即可成功.
注意：确保远程仓库地址是SSH格式(如git@github.com:[user-name]/[repo-name].git), 而非HTTPS.</description>
    </item>
    
  </channel>
</rss>
