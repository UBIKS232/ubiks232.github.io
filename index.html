<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta name="generator" content="Hugo 0.92.2" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ubiks232&#39;s blog</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/chroma.css">
</head>
<body>
    <div class="container">
        <h1>ubiks232&#39;s blog</h1>

        <div class="taxonomies">
            
            <div>
                <strong>Categories:</strong>
                
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                <a href="/categories/embedded-linux/">embedded-linux</a> <a href="/categories/init/">init</a> <a href="/categories/rt-thread/">rt-thread</a> <a href="/categories/rtfsc/">rtfsc</a> <a href="/categories/stm32%E5%B9%B3%E8%A1%A1%E8%BD%A6/">stm32平衡车</a> <a href="/categories/ulupa/">ulupa</a> <a href="/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a>
            </div>
            

            
            <div>
                <strong>Tags:</strong>
                
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                    
                    
                
                <a href="/tags/c/">c</a> <a href="/tags/embedded/">embedded</a> <a href="/tags/git/">git</a> <a href="/tags/init/">init</a> <a href="/tags/linux/">linux</a> <a href="/tags/os/">os</a> <a href="/tags/read-a-book/">read-a-book</a> <a href="/tags/rtos/">rtos</a> <a href="/tags/stm32/">stm32</a> <a href="/tags/strange-bug/">strange-bug</a> <a href="/tags/zynq/">zynq</a>
            </div>
            
        </div>

        <p>Left blank.</p>

        <h2>Recent Articles</h2>
        
            
            <article>
                <h3><a href="/posts/stm32balancecar-1-adc/">STM32 Balance Car 1 ADC</a></h3>
                <time datetime="2026-01-12T00:32:21&#43;08:00">
                    2026-1-12
                </time>
                <p>铁头山羊的教程
adc相关bug 测试时遇到Delay()函数不能正确执行的bug, 有如下几个排查方向:
 Delay()是否被编译器优化? 该函数内部的变量更新是由__weak Systick_Handler()实现的, 这个中断处理是否能正常执行?  1 在Keil5调试界面的汇编代码对照中, 能够看到:
1 2 3  22: Delay(1000);0x08001BB6F44F707AMOVr0,#0x3E80x08001BBAF7FEFED7BL.W0x0800096CDelay  说明Delay()能被正确编译, 没有被优化.
2 在进入Delay()之后, 出现了突然跳到ADC1_2_IRAHandler的情况, 这个ADC1_2_IRAHandler被我用于处理ADC1转换得到的数据, 并且在调试卡死一段时间后, 又回到了Delay()中继续执行, 似乎并不能正确进入Systick_Handler().
此时我产生了两个怀疑: 1, Systick_Handler()是不是被优化掉了; 2, ADC1_2_IRQHandler似乎抢占了Systick_Handler()的执行.
首先看1, 在stm32f10x_it.c中查看Systick_Handler()的实现:
1 2 3 4 5 6 7 8 9  extern __IO uint32_t ulTicks; void SysTick_Handler(void) { if (SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG) { ulTicks++; } }   先声明了外部变量ulTicks, 然后根据ST公司提供的TM0056中的&quot;Bit 16 COUNTFLAG: Returns 1 if timer counted to 0 since last time this was read.</p>
            </article>
            
            <article>
                <h3><a href="/posts/zynq-linux-1-%E5%BB%BA%E7%AB%8Bnfs/">Zynq Linux 1 建立nfs</a></h3>
                <time datetime="2026-01-07T18:21:39&#43;08:00">
                    2026-1-7
                </time>
                <p>环境: Windows11 + WSL2的Ubuntu22.04, 开启Windows对WSL2的镜像网络, 在WSL2的配置(.wslconfig)中加上:
1 2  [wsl2] networkingMode=mirrored    1 Windows防火墙的入站许可-1(后面还要设置Windows的防火墙) 按照(Windows11下)Control Panel -&gt; System and Security -&gt; Windows Denfender Firewall -&gt; Advanced Settings -&gt; Inbound Rules -&gt; 找到: File and Printer Sharing (Echo Request - ICMPv4-In), 然后右键点击Enable Rule, 这样允许zynq uboot通过以太网ping主机.
 2 配置以太网连接 由于开启了镜像网络, 因此WSL2上的虚拟机与Windows共享同一个网卡, 只需要将Windows的以太网设置好就行了.
比如我将Windows的eth设置成:
1 2  ipv4 addr: 192.168.2.10 netmask: 255.255.255.0   暂时先不设置网关, DNS, IPv6等内容. 在启动zynq上的Linux之前, 先中断系统引导停留在uboot阶段, 使用setenv配置网络, 将地址写为同一网段的地址.</p>
            </article>
            
            <article>
                <h3><a href="/posts/ulupa-2.6-cp/">ULUPA-2.6-cp</a></h3>
                <time datetime="2026-01-07T13:35:35&#43;08:00">
                    2026-1-7
                </time>
                <p>Understanding Linux/Unix Programming A Guide 2 Theory And Practice
简单的cp实现起来很清楚: {创建新文件+打开旧文件}-&gt;使用缓存的字节数组读取旧文件-&gt;将读取的内容写入新文件-&gt;{关闭新文件+关闭旧文件}.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; #define BUFFERSIZE 4096 #define COPYMODE 0644  void oops(int pos, char *err); int main(int argc, char *argv[]) { int old_fd, new_fd, n_char; char buf[BUFFERSIZE]; // if(argc !</p>
            </article>
            
            <article>
                <h3><a href="/posts/ulupa-2.5-who/">ULUPA-2.5-who</a></h3>
                <time datetime="2026-01-06T20:59:11&#43;08:00">
                    2026-1-6
                </time>
                <p>Understanding Linux/Unix Programming A Guide 2 Theory And Practice
who是怎么工作的? 是怎么实现的? 使用man who查询得到&quot;&hellip;If FILE is not specified, use /var/run/utmp. /var/log/wtmp as FILE is common&hellip;&quot;, 因此应该寻找一个读取utmp/wtmp文件的方法, 此时需要知道这两个个文件的数据结构.
使用man -k utmp, 查找与utmp相关的条目, 在我的系统上找到utmp (5) - login records的记录, 因此使用man 5 utmp查询, 得到utmp文件中的数据结构, 即以结构体utmpx或utmp形式组织的数据结构.
能不能自己写一个who? 简单的实现方式, 就是使用read读取文件, 然后使用格式化输出打印到终端, 这个过程需要使用只读的方式打开utmp文件, 因此还要使用到open和close, 格式化输出过程中, 登陆时间显示的是描述, 使用ctime将其转化为日期加时间的表示方式.
最终效果如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include &lt;stdio.</p>
            </article>
            
            <article>
                <h3><a href="/posts/windows%E4%B8%8Bgit-push%E6%98%BE%E7%A4%BApermission-denied%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3/">Windows下git Push显示permission Denied问题排查与解决</a></h3>
                <time datetime="2026-01-04T23:31:56&#43;08:00">
                    2026-1-4
                </time>
                <p>1. Windows下ssh -T能通, 但是git push推送失败 2. 前提：ssh key已正确生成, 并且公钥已添加到GitHub(或其他 Git 平台). 3. 现象： 在PowerShell中执行git push报错：
1 2  git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.   但执行ssh -T git@github.com却显示认证成功.
4. 原因： git推送时使用的ssh可执行文件和测试用的ssh可执行文件不是同一个可执行文件.
使用where.exe ssh找到的是C:\Windows\System32\OpenSSH\ssh.exe, 而通过git config --global core.sshCommand发现, Git for Windows使用了它自带的ssh.exe(如.../Git/usr/bin/ssh.exe), 而该ssh与Windows的OpenSSH相比, 无法正确加载位于Windows用户目录下的私钥, 造成前面的问题.
5. 解决方法： 强制git使用Windows自带的 OpenSSH：
1  git config --global core.sshCommand &#34;C:/Windows/System32/OpenSSH/ssh.exe&#34;   之后再次执行git push即可成功.
注意：确保远程仓库地址是SSH格式(如git@github.com:[user-name]/[repo-name].git), 而非HTTPS.</p>
            </article>
            
            <article>
                <h3><a href="/posts/%E9%98%85%E8%AF%BBrt-thread%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E6%89%8B%E5%86%8C-3/">阅读RT-Thread内核实验手册-3</a></h3>
                <time datetime="2026-01-04T18:22:21&#43;08:00">
                    2026-1-4
                </time>
                <p>EXP 7 事件集的使用 1.事件的发布者使用不同的事件标志(event_flag)发布事件, 事件的接收者在recv函数中写入所要接收的flag以及对多个flag的判断方式(OR, AND&hellip;), 并且进行清空flag的操作, 完成一次事件的发送与接收;
2.事件集用于达到多条件情况下线程间同步.
EXP 8 邮箱的使用 1.邮箱可以缓存消息, 比如使用FIFO(RT_IPC_FLAG_FIFO)的方式进行非同步线程通信, 邮箱的大小(邮件数)可以自己定义, 具体为邮件数 = 所定义的字节数组大小(内存池大小) / 4, 即最大消息大小为4字节;
2.接收者以轮询的方式进行邮件内容接收.
EXP 9 消息队列的使用 1.用于异步通信的机制, 可以用于接收中断或者普通线程所发布的不定长消息, 消息缓存的方式可以是FIFO;
2.AIGC by Qwen3:
1 2 3 4  ✅ 用 FIFO： 两个进程间传递连续数据流（如传感器数据、日志），且无需消息边界. ✅ 用消息队列： 需要解耦、异步、可靠、带优先级/类型的通信，如微服务间事件通知、订单处理系统.   EXP 10 动态内存堆的使用 使用rt_malloc以及rt_free用于申请和释放动态内存, rt_malloc的返回值为RT_NULL时为申请失败.</p>
            </article>
            
            <article>
                <h3><a href="/posts/%E9%98%85%E8%AF%BBrt-thread%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E6%89%8B%E5%86%8C-2/">阅读RT-Thread内核实验手册-2</a></h3>
                <time datetime="2026-01-03T19:04:13&#43;08:00">
                    2026-1-3
                </time>
                <p>RT-Thread内核实验手册
EXP 5 信号量—生产者消费者问题 1.信号量为0时不可以获取该信号量;
2.信号量的获取和发布分别对应让信号量的值减一或加一;
3.结合(1.)的说法, 可以使用一个初始值为1的信号量对其获取和发布起到一个锁的作用, 比如操作一个不同线程之间共用的数组时, 各个线程内可以在操作数组之前获取该信号量, 完成之后发布;
4.信号量可以用于非同步线程之间的通信, 结合(3.)实现的读写锁, 借由数组作为FIFO传递数据;
5.等待信号量时的挂起rt_sem_take可以使用RT_WAITING_FOREVER关键字.
6 互斥量—优先级继承 1.AIGC by Qwen3:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161  Q.</p>
            </article>
            
            <article>
                <h3><a href="/posts/%E9%98%85%E8%AF%BBrt-thread%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E6%89%8B%E5%86%8C-1/">阅读RT-Thread内核实验手册-1</a></h3>
                <time datetime="2025-12-30T18:11:24&#43;08:00">
                    2025-12-30
                </time>
                <p>RT-Thread内核实验手册
EXP 2 线程的使用 不同优先级的线程间以抢占的方式进行调度, 进程可以用动态创建或者静态初始化, 被设计为死循环的线程一定要在循环中有让出CPU使用权的动作, 比如延时rt_thread_mdelay.
EXP 3 线程的时间片轮转调度 1.相同优先级的进程使用时间片轮转方式进行调度, 自己可以定义一个THREAD_TIMESLICE来写入进程的时间片长度;
2.两个不同进程可以使用同样的入口函数, 但是函数中相同的变量会被存储在不同的堆空间.
Q: 在RT-Thread中, stack size应该依据什么设置?
EXP 4 定时器的使用 定时器可以是周期(periodic)定时器, 也可以是单次(one-shot)计时器, 默认使用HARD_TIMER, 定时器到达所定的时间周期时, OS会调取超时函数处理, 超时函数在初始化定时器时注册.</p>
            </article>
            
            <article>
                <h3><a href="/posts/hello-world/">Hello World</a></h3>
                <time datetime="2025-12-25T14:56:41&#43;08:00">
                    2025-12-25
                </time>
                <p>This is my first plain Hugo post!
 No theme Some CSS Much HTML and Markdown  Test git push.</p>
            </article>
            
        
    </div>

    <footer class="site-footer">
        Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a> |
        Website by <a href="https://github.com/UBIKS232" target="_blank" rel="noopener">ubiks232</a> |
        E-mail: ubik DOT 3141 AT gmail DOT com
    </footer>
</body>
</html>